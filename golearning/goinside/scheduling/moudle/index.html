<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          Fred&#39;s Book
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-exp.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 6.1.0"></head>

<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>FRED&#39;S BOOK</span>
  </a>
</div>
    <div id="menu" class="book-menu hide">
  <ul>
<li><a href="/">Home</a></li>
<li><a target="_blank" rel="noopener" href="https://fred-tt.github.io/">作者主页</a></li>
</ul>
<h1 id="深入浅出Go语言-v2">深入浅出Go语言</h1>
<ul>
<li><a href="/golearning/introduction">引言</a></li>
<li>上篇.深入Go语言
<ul>
<li>
<p>第一章 汇编基础</p>
<ul>
<li><a href="/golearning/goinside/assembly/abstract">1.1 概述</a></li>
<li><a href="/golearning/goinside/assembly/base">1.2 基础知识</a></li>
<li><a href="/golearning/goinside/assembly/stack">1.3 调用栈</a></li>
<li><a href="/golearning/goinside/assembly/summary">1.4 小结</a></li>
</ul>
</li>
<li>
<p>第二章 调度模型</p>
<ul>
<li><a href="/golearning/goinside/scheduling/abstract">2.1 概述</a></li>
<li><a href="/golearning/goinside/scheduling/coroutine">2.2 协程</a></li>
<li><a href="/golearning/goinside/scheduling/moudle">2.3 调度模型</a></li>
<li><a href="/golearning/goinside/scheduling/newproc">2.4 创建协程</a></li>
<li><a href="/golearning/goinside/scheduling/schedule">2.5 循环调度</a></li>
<li><a href="/golearning/goinside/scheduling/sysmon">2.6 系统监控</a></li>
<li><a href="/golearning/goinside/scheduling/summary">2.7 小结</a></li>
</ul>
</li>
<li>
<p>第三章 进程启动</p>
<ul>
<li><a href="/golearning/goinside/startup/abstract">3.1 概述</a></li>
<li><a href="/golearning/goinside/startup/startup">3.2 进程启动</a></li>
<li><a href="/golearning/goinside/startup/tls">3.3 线程本地存储</a></li>
<li><a href="/golearning/goinside/startup/param">3.4 入参传递</a></li>
<li><a href="/golearning/goinside/startup/summary">3.5 小结</a></li>
</ul>
</li>
<li>
<p>第四章 内存管理</p>
</li>
</ul>
</li>
</ul>

</div>


<script src="/js/book-menu.js"></script>

  </div>

  <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

  <div class="off-canvas-content">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <h3 id="调度模型">调度模型</h3>
<hr>
<p>在1.1版本后，Go采用GMP模型调度协程，其逻辑结构如下图所示。</p>
<p><img src="/assets/images/golearing/image-20220505211827389.png" alt="image-20220505211827389"></p>
<p>调度模型由4类对象schedt，m，p，g组成，其中：</p>
<p>schedt对象：scheduler，整个进程一个实例，代表整个调度框架。</p>
<p>m对象：machine，每个m对象绑定一个操作系统线程，调度goroutine。</p>
<p>p对象：processor，其个数一般和进程所在容器（物理机，虚拟机，容器等）的核数相同，负责维护g对象和本地内存管理。</p>
<p>g对象：goroutine，程序最小执行单元，进程中有大量的goroutine，其数量一般来说没有上限。</p>
<p>正如上节讲到的通用的携程调度模型，在GMP模型中，goroutine被m周而复始的调度，但是在调度过程中运用了比较复杂的算法，以求达到最佳的调度效率。下面将详细讲解上述四类对象维护的资源，生命周期以及关键处理流程。</p>
<h4 id="schedt对象">schedt对象</h4>
<p>schedt对象代表整个调度框架，以全局变量的形式存在，其维护以下关键资源（详见runtime2.go文件中schedt结构体定义）：</p>
<ul>
<li>midle：空闲的m（实际上是m链表）</li>
<li>mnext：下一个m</li>
<li>pidle：空闲的p（实际上是p链表）</li>
<li>runq：全局可运行g队列</li>
<li>gFree：全局死亡的g</li>
<li>freem：待释放的m</li>
</ul>
<h5 id="schedt对象的创建">schedt对象的创建</h5>
<p>schedt对象是一个全局变量，在进程启动初始化阶段完成初始化，初始化函数的<code>schedinit()</code>。schedt对象的生命周期和进程的生命周期相同，不存在主动释放过程。</p>
<p>schedt对象更多起到容器的功能，存放各种资源，在调度过程中，并不参与实际的调度。</p>
<h4 id="M对象">M对象</h4>
<p>m对象代表一个调度器，其维护以下关键资源（详见runtime2.go文件中m结构体定义）：</p>
<ul>
<li>g0：m绑定的第0个goroutine</li>
<li>tls：线程级本地存储</li>
<li>curg：当前调度的goroutine</li>
<li>p：当前绑定的p</li>
<li>nextp：下一个可以调度的p</li>
</ul>
<h5 id="m对象的创建">m对象的创建</h5>
<p>创建m对象有如下4种场景：</p>
<ul>
<li>进程启动线程作为m0；</li>
<li>进程启动过程中，创建监控m，执行sysmon函数；</li>
<li>在创建g时，如果没有空闲的m，则创建一个m；</li>
<li>cgo用到的模板m；</li>
</ul>
<p>m对象的创建函数是newm，在创建m的过程中会创建一个操作系统线程和一个默认的协程g0。m绑定的操作系统线程的入口函数为mstart，对于监控m和模板m，将分别死循环执行<code>sysmon()</code>和<code>templateThread()</code>函数；其它创建的m调用这个函数后将周而复始调用<code>shcedule()</code>函数实现对可运行协程的调度（详细过程可以查看后续的代码解析-创建m章节）。</p>
<h5 id="m对象的休眠">m对象的休眠</h5>
<p>停止m对象有如下5种场景：</p>
<ul>
<li>锁定m绑定的操作系统线程</li>
<li>当进程处于gc等待阶段</li>
<li>当网络监控器无连接事件</li>
<li>无可运行的g</li>
<li>系统调用退出</li>
</ul>
<p>停止m对象调用的是stopm ()，在该函数中，m将被放入schedt对象的midle链中，同时调用mPark休眠直到被唤醒。</p>
<h5 id="m对象的唤醒">m对象的唤醒</h5>
<p>对于停止的m，在如下场景下将被唤醒：</p>
<ul>
<li>gc结束，重启所有的m</li>
<li>为p启动m，当sched.midle有空闲的m</li>
</ul>
<p>唤醒m对象调用的是<code>notewakeup()</code>函数，在该函数中，将设置m的停止标志key为1，mPark函数退出休眠，m被唤醒。</p>
<h5 id="m对象的退出">m对象的退出</h5>
<p>只有在异常情况下m才会退出。</p>
<h4 id="P对象">P对象</h4>
<p>代表processor，维护以下关键资源：</p>
<ul>
<li>mcache：缓存</li>
<li>m：当前绑定的m</li>
<li>runq：本地可运行g队列</li>
<li>runnext：下一个可运行的g</li>
<li>gFree：处于Gdead状态的g</li>
</ul>
<h5 id="p对象的创建">p对象的创建</h5>
<p>p对象在进程启动初始化阶段的<code>schedinit()</code>函数创建好，保存在<code>allp</code>全局变量中，p的个数有当前所在容器的CPU核数和设置的MAXPROCS数值决定。</p>
<h5 id="p对象的休眠">p对象的休眠</h5>
<p>p对象在以下场景下被休眠：</p>
<ul>
<li>当m退出或者停止时，m上绑定的p将休眠</li>
<li>gc阶段，将处于系统调用的p休眠</li>
</ul>
<p>休眠p调用的是函数<code>handoffp()</code>，休眠的前提是该p上的可运行g队列为空。休眠的p将被存入sched对象的pidle链表中，等待被唤醒。</p>
<h5 id="p对象的唤醒">p对象的唤醒</h5>
<p>p对象在以下场景下被唤醒：</p>
<ul>
<li>g对象被唤醒</li>
<li>gc结束</li>
<li>创建一个g对象</li>
<li>调度非寻常goroutine</li>
<li>启动m对象</li>
</ul>
<p>唤醒p将从sched对象的pidle链表获取一个p对象，并将p对象绑定到m对象，等待调度。</p>
<h4 id="g对象">g对象</h4>
<p>g对象代表goroutine，维护以下关键资源：</p>
<p>代表goroutine，维护以下关键资源：</p>
<ul>
<li>stack：协程栈</li>
<li>sched：用于保存协程调度的上下文</li>
</ul>
<h5 id="g对象的创建">g对象的创建</h5>
<p>goroutine在以下5种情况下创建：</p>
<ul>
<li>
<p>进程启动过程中创建的g0</p>
</li>
<li>
<p>每创建一个m，会自动创建一个g0</p>
</li>
<li>
<p>进程启动过程中用于执行main函数的g</p>
</li>
<li>
<p>进程启动过程中，创建的背景扫描和清理g，用于gc</p>
</li>
<li>
<p>用户创建的goroutine</p>
</li>
</ul>
<p>在汇编代码中，g对象是通过<code>call runtime·newproc</code>创建的，在go代码中，则是通过<code>go func()</code>创建的（go是一个内建标识符，编译成汇编也是调用的runtime·newproc）。</p>
<h5 id="g对象的休眠">g对象的休眠</h5>
<p>goroutine在以下场景下休眠：</p>
<ul>
<li>读写channel阻塞时</li>
<li>调用sleep时</li>
<li>创建goroutine，并主动休眠等待被调度</li>
<li>调用select时阻塞</li>
</ul>
<p>休眠goroutine调用的是<code>gopark()</code>函数，在<code>gopark()</code>函数中，将切换到g0协程，并执行<code>schedule()</code>继续调度其它协程。</p>
<h5 id="g对象的唤醒">g对象的唤醒</h5>
<p>goroutine在以下场景下被唤醒：</p>
<ul>
<li>channel有数据或者空间可以读写</li>
<li>sleep时间到</li>
<li>创建goroutine，并主动休眠等待被调度</li>
<li>select信号到达</li>
</ul>
<p>唤醒goroutine调用的是<code>goready()</code>函数，在goready()函数中将再次将goroutine放到本地可运行g队列的next位置，等待调度，并唤醒所在的p。</p>
<h5 id="g对象的退出">g对象的退出</h5>
<p>当goroutine执行完后，goroutine将退出，调度框架将m切换到g0，并继续执行<code>schedule()</code>继续调度其它协程。</p>
<h4 id="调度过程">调度过程</h4>
<h5 id="初始化">初始化</h5>
<p>在进程启动初始化过程中，完成以下操作：</p>
<ol>
<li>将引导进程启动的协程设置为全局g0，将引导进程启动的线程设置为全局m0，g0的调度m设置成m0；</li>
<li>初始化p对象，并将g0的调度m（即m0）的p设置成allp[0]；</li>
<li>初始化sched对象，创建全局可运行队列，并将所有的p加入pidle队列中；</li>
<li>创建运行<code>runtime·main</code>函数（该函数调用用户的main函数）的goroutine，并设置为g0所在p的runnext，等待调度；</li>
<li>启动m0，进入循环调度<code>schedule()</code>状态；</li>
<li>首先调度<code>runtime·main</code>的协程，在该协程执行函数中将创建系统监控sysmon，同时创建背景gc使用的sweep和scavenge协程，然后调用用户定义的main函数（一般是一直阻塞）。</li>
</ol>
<p>经过初始化过程后，运行时调度器（抛开用户main函数的执行）的状态如下图所示。</p>
<p><img src="/assets/images/golearing/image-20220508212809998.png" alt="image-20220508212809998"></p>
<h5 id="循环调度">循环调度</h5>
<p>m在循环调度过程中，调度优先级冲高到低为：绑定的p的runnext，绑定的p的本地可运行队列队首的g，全局可运行队列队首的g，网络监控器（netpoll）中当前处于就绪状态的g，其它p的本地可运行队列中的g，gc状态下的gc worker的g。如果选择到合适的g，则调用<code>execute()</code>执行该协程，否则休眠当前的p和m。</p>
<p>当调度的g执行完成后，m再次调用schedule()调度下一个g，如此循环调度。</p>
<h5 id="创建协程-v2">创建协程</h5>
<p>在<code>main</code>函数启动执行后，如果使用<code>go</code>创建协程时，默认情况（非随机调度）下，新建的协程会被设置成当前执行goroutine的m所绑定的p的runnext，等待优先调度，并将旧的runnext的goroutine放到本地可运行队列的尾部。如果是随机调度，新建的goroutine将随机放到本地可运行队列的尾部或者被设置成runnext。</p>
<p>当p的本地可运行队列满（装载的g达到256个），则将本地可运行队列中一般的g搬移到全局可运行队列。</p>
<p>接下来唤醒p，唤醒p的过程中，如果sched上没有空闲的p，则不做任何处理，否则调用starm()启动m。在starm()函数中，优先唤醒处于休眠状态的m，如果不存在休眠的m，则新建m。唤醒或者新建的m再次进入循环调度状态。</p>
<p>上述初步描述了go的GMP调度模型，相关的代码的解读将在本章后续小节中描述。</p>

</div>


  <div class="book-comments">
    




  </div>



<script src="/js/book-post.js"></script>

        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="F"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>Fred</div>
      <div>2022-05-08</div>
    </div>
  </div>

  

  <div class="divider"></div>
</div>
  

  <div class="book-tocbot">
</div>
<!-- <div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div> -->


<script src="/js/book-toc.js"></script>

</div>
      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>


<script src="/js/book.js"></script>
