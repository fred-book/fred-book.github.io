<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="google-site-verification" content="s-8IF8tA8PvTbm8zqPM7lsTYTh9cNli__Ow9DNcriYc" />
    <meta name="baidu-site-verification" content="code-XuUFITwPa7" />
    <meta name="msvalidate.01" content="89FF12DB155A91466B832D8311C1E0EB" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          Fred&#39;s Book
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-exp.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 6.1.0"></head>

<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>FRED&#39;S BOOK</span>
  </a>
</div>
    <div id="menu" class="book-menu hide">
  <ul>
<li><a href="/">Home</a></li>
<li><a target="_blank" rel="noopener" href="https://fred-tt.github.io/">作者主页</a></li>
</ul>
<h1 id="深入浅出Go语言-v2">深入浅出Go语言</h1>
<ul>
<li><a href="/golearning/introduction">引言</a></li>
<li>上篇.深入Go语言
<ul>
<li>
<p>第一章 汇编基础</p>
<ul>
<li><a href="/golearning/goinside/assembly/abstract">1.1 概述</a></li>
<li><a href="/golearning/goinside/assembly/base">1.2 基础知识</a></li>
<li><a href="/golearning/goinside/assembly/stack">1.3 调用栈</a></li>
<li><a href="/golearning/goinside/assembly/summary">1.4 小结</a></li>
</ul>
</li>
<li>
<p>第二章 调度模型</p>
<ul>
<li><a href="/golearning/goinside/scheduling/abstract">2.1 概述</a></li>
<li><a href="/golearning/goinside/scheduling/coroutine">2.2 协程</a></li>
<li><a href="/golearning/goinside/scheduling/moudle">2.3 调度模型</a></li>
<li><a href="/golearning/goinside/scheduling/newproc">2.4 创建协程</a></li>
<li><a href="/golearning/goinside/scheduling/schedule">2.5 循环调度</a></li>
<li><a href="/golearning/goinside/scheduling/sysmon">2.6 系统监控</a></li>
<li><a href="/golearning/goinside/scheduling/summary">2.7 小结</a></li>
</ul>
</li>
<li>
<p>第三章 进程启动</p>
<ul>
<li><a href="/golearning/goinside/startup/abstract">3.1 概述</a></li>
<li><a href="/golearning/goinside/startup/startup">3.2 进程启动</a></li>
<li><a href="/golearning/goinside/startup/tls">3.3 线程本地存储</a></li>
<li><a href="/golearning/goinside/startup/param">3.4 入参传递</a></li>
<li><a href="/golearning/goinside/startup/summary">3.5 小结</a></li>
</ul>
</li>
<li>
<p>第四章 内存管理</p>
<ul>
<li><a href="/golearning/goinside/memory/abstract">4.1 概述</a></li>
<li><a href="/golearning/goinside/memory/memory">4.2 内存管理</a></li>
<li><a href="/golearning/goinside/memory/newobject">4.3 创建对象</a></li>
<li><a href="/golearning/goinside/memory/gc">4.4 垃圾回收</a></li>
<li><a href="/golearning/goinside/memory/summary">4.5 小结</a></li>
</ul>
</li>
</ul>
</li>
</ul>

</div>


<script src="/js/book-menu.js"></script>

  </div>

  <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

  <div class="off-canvas-content">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <h3 id="创建对象">创建对象</h3>
<hr>
<h4 id="创建对象-v2">创建对象</h4>
<p>在Golang中，对于使用者来说，面对的是对象object。在创建对象的时候Golang会为对象申请内存，并进行赋初值。创建对象包含创建单个对象和对象数组，其函数如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newobject</span><span class="params">(typ *_type)</span></span> unsafe.Pointer &#123;</span><br><span class="line">   <span class="keyword">return</span> mallocgc(typ.size, typ, <span class="literal">true</span>) <span class="comment">// 为typ类型的对象申请内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newarray</span><span class="params">(typ *_type, n <span class="type">int</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">   <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mallocgc(typ.size, typ, <span class="literal">true</span>) <span class="comment">// 如果数组长度为1，则直接申请typ类型的内存空间</span></span><br><span class="line">   &#125;</span><br><span class="line">   mem, overflow := math.MulUintptr(typ.size, <span class="type">uintptr</span>(n))</span><br><span class="line">   <span class="keyword">if</span> overflow || mem &gt; maxAlloc || n &lt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(plainError(<span class="string">&quot;runtime: allocation size out of range&quot;</span>))</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> mallocgc(mem, typ, <span class="literal">true</span>) <span class="comment">// 如果数组长度大于1，则直接申请n个typ类型的内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码可以看出，两个函数最终都是调用内存分配函数<code>mallocgc</code>。<code>mallocgc</code>函数主要实现了对极小对象，一般对象和大对象的内存申请。</p>
<h5 id="申请极小对象">申请极小对象</h5>
<p>对于长度小于16字节且不为指针的极小对象，会从<code>mcache</code>的<code>tiny</code>为其申请内存。<code>tiny</code>本身为16字节的内存块（从规格为2的mspan中申请的对象），Golang会非常精细化使用该16字节内存块。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line">    off := c.tinyoffset<span class="comment">//获取当前tiny已经被使用的内存偏移，并按照合适长度对齐</span></span><br><span class="line">    <span class="keyword">if</span> size&amp;<span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">        off = alignUp(off, <span class="number">8</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> goarch.PtrSize == <span class="number">4</span> &amp;&amp; size == <span class="number">12</span> &#123;</span><br><span class="line">        off = alignUp(off, <span class="number">8</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">        off = alignUp(off, <span class="number">4</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">        off = alignUp(off, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="number">0</span> &#123;<span class="comment">// 如果tiny剩余长度足够分配申请长度，则返回对应地址，更新tiny使用偏移</span></span><br><span class="line">        <span class="comment">// The object fits into existing tiny block.</span></span><br><span class="line">        x = unsafe.Pointer(c.tiny + off)</span><br><span class="line">        c.tinyoffset = off + size</span><br><span class="line">        c.tinyAllocs++</span><br><span class="line">        mp.mallocing = <span class="number">0</span></span><br><span class="line">        releasem(mp)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从规格2的mspan中申请一个新的object</span></span><br><span class="line">    span = c.alloc[tinySpanClass]</span><br><span class="line">    v := nextFreeFast(span)</span><br><span class="line">    <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">        v, span, shouldhelpgc = c.nextFree(tinySpanClass)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新申请的16字节对象清零</span></span><br><span class="line">    x = unsafe.Pointer(v)</span><br><span class="line">    (*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    (*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 如果申请内存size小于已被使用内存偏移或者tiny对象为空，则替换tiny；否则退化成一般对象申请</span></span><br><span class="line">    <span class="keyword">if</span> !raceenabled &amp;&amp; (size &lt; c.tinyoffset || c.tiny == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Note: disabled when race detector is on, see comment near end of this function.</span></span><br><span class="line">        c.tiny = <span class="type">uintptr</span>(x)</span><br><span class="line">        c.tinyoffset = size</span><br><span class="line">    &#125;</span><br><span class="line">    size = maxTinySize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果tiny上的内存使用完或者不够本次申请，则从mache本地规格2的mspan中获取一个空闲的对象，如果本地mspan没有空闲的对象，则向mheap申请一个同规格的mspan。</p>
<h5 id="申请一般对象">申请一般对象</h5>
<p>对于指针类型极小对象和长度不小于16字节且小于32768字节的对象，则通过一般对象申请流程申请内存。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sizeclass <span class="type">uint8</span></span><br><span class="line"><span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123; <span class="comment">// 获取申请内存长度所属规格</span></span><br><span class="line">    sizeclass = size_to_class8[divRoundUp(size, smallSizeDiv)]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sizeclass = size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]</span><br><span class="line">&#125;</span><br><span class="line">size = <span class="type">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">spc := makeSpanClass(sizeclass, noscan) <span class="comment">// 根据内存规格和是否扫描获取mspan规格</span></span><br><span class="line">span = c.alloc[spc] <span class="comment">// 从mspan中获取object，如果本地的mspan已满，则向mheap重新申请一个mspan</span></span><br><span class="line">v := nextFreeFast(span)</span><br><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">    v, span, shouldhelpgc = c.nextFree(spc)</span><br><span class="line">&#125;</span><br><span class="line">x = unsafe.Pointer(v)</span><br><span class="line"><span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">    memclrNoHeapPointers(unsafe.Pointer(v), size) <span class="comment">// 将申请的内存清零</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，优先从mache本地mspan中获取一个空闲的对象，如果本地mspan没有空闲的对象，则向mheap申请一个同规格的mspan。</p>
<h5 id="申请大对象">申请大对象</h5>
<p>对于内存长度小于32768字节的对象，认为是大对象，直接从mheap申请内存。大对象长度大于32768字节，超过了前一节讲到的mspan规格，但是管理上仍以mspan对象管理，挂载在规格为1的mspan对象下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">shouldhelpgc = <span class="literal">true</span></span><br><span class="line"><span class="comment">// For large allocations, keep track of zeroed state so that</span></span><br><span class="line"><span class="comment">// bulk zeroing can be happen later in a preemptible context.</span></span><br><span class="line">span = c.allocLarge(size, noscan) <span class="comment">// 申请大对象，仍然按照mspan对象管理，挂载在规格为1的mspan对象上</span></span><br><span class="line">span.freeindex = <span class="number">1</span></span><br><span class="line">span.allocCount = <span class="number">1</span></span><br><span class="line">size = span.elemsize</span><br><span class="line">x = unsafe.Pointer(span.base())</span><br><span class="line"><span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> noscan &#123;</span><br><span class="line">        delayedZeroing = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        memclrNoHeapPointers(x, size)</span><br><span class="line">        <span class="comment">// We&#x27;ve in theory cleared almost the whole span here,</span></span><br><span class="line">        <span class="comment">// and could take the extra step of actually clearing</span></span><br><span class="line">        <span class="comment">// the whole thing. However, don&#x27;t. Any GC bits for the</span></span><br><span class="line">        <span class="comment">// uncleared parts will be zero, and it&#x27;s just going to</span></span><br><span class="line">        <span class="comment">// be needzero = 1 once freed anyway.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="更新arena">更新arena</h5>
<p>对于包含指针的对象，在申请完内存后会将对象的指针引用信息保存到arena。其实现函数为<code>runtime.heapBitsSetType</code>，这是一个非常复杂的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapBitsSetType</span><span class="params">(x, size, dataSize <span class="type">uintptr</span>, typ *_type)</span></span> &#123;</span><br><span class="line">   <span class="keyword">const</span> doubleCheck = <span class="literal">false</span> <span class="comment">// slow but helpful; enable to test modifications to this code</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> (</span><br><span class="line">      mask1 = bitPointer | bitScan                        <span class="comment">// 00010001</span></span><br><span class="line">      mask2 = bitPointer | bitScan | mask1&lt;&lt;heapBitsShift <span class="comment">// 00110011</span></span><br><span class="line">      mask3 = bitPointer | bitScan | mask2&lt;&lt;heapBitsShift <span class="comment">// 01110111</span></span><br><span class="line">   )</span><br><span class="line"></span><br><span class="line">   <span class="comment">// dataSize is always size rounded up to the next malloc size class,</span></span><br><span class="line">   <span class="comment">// except in the case of allocating a defer block, in which case</span></span><br><span class="line">   <span class="comment">// size is sizeof(_defer&#123;&#125;) (at least 6 words) and dataSize may be</span></span><br><span class="line">   <span class="comment">// arbitrarily larger.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// The checks for size == goarch.PtrSize and size == 2*goarch.PtrSize can therefore</span></span><br><span class="line">   <span class="comment">// assume that dataSize == size without checking it explicitly.</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> goarch.PtrSize == <span class="number">8</span> &amp;&amp; size == goarch.PtrSize &#123;</span><br><span class="line">      <span class="comment">// It&#x27;s one word and it has pointers, it must be a pointer.</span></span><br><span class="line">      <span class="comment">// Since all allocated one-word objects are pointers</span></span><br><span class="line">      <span class="comment">// (non-pointers are aggregated into tinySize allocations),</span></span><br><span class="line">      <span class="comment">// initSpan sets the pointer bits for us. Nothing to do here.</span></span><br><span class="line">      <span class="keyword">if</span> doubleCheck &#123;</span><br><span class="line">         h := heapBitsForAddr(x)</span><br><span class="line">         <span class="keyword">if</span> !h.isPointer() &#123;</span><br><span class="line">            throw(<span class="string">&quot;heapBitsSetType: pointer bit missing&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> !h.morePointers() &#123;</span><br><span class="line">            throw(<span class="string">&quot;heapBitsSetType: scan bit missing&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   h := heapBitsForAddr(x)</span><br><span class="line">   ptrmask := typ.gcdata <span class="comment">// start of 1-bit pointer mask (or GC program, handled below)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2-word objects only have 4 bitmap bits and 3-word objects only have 6 bitmap bits.</span></span><br><span class="line">   <span class="comment">// Therefore, these objects share a heap bitmap byte with the objects next to them.</span></span><br><span class="line">   <span class="comment">// These are called out as a special case primarily so the code below can assume all</span></span><br><span class="line">   <span class="comment">// objects are at least 4 words long and that their bitmaps start either at the beginning</span></span><br><span class="line">   <span class="comment">// of a bitmap byte, or half-way in (h.shift of 0 and 2 respectively).</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> size == <span class="number">2</span>*goarch.PtrSize &#123;</span><br><span class="line">      <span class="keyword">if</span> typ.size == goarch.PtrSize &#123;</span><br><span class="line">         <span class="comment">// We&#x27;re allocating a block big enough to hold two pointers.</span></span><br><span class="line">         <span class="comment">// On 64-bit, that means the actual object must be two pointers,</span></span><br><span class="line">         <span class="comment">// or else we&#x27;d have used the one-pointer-sized block.</span></span><br><span class="line">         <span class="comment">// On 32-bit, however, this is the 8-byte block, the smallest one.</span></span><br><span class="line">         <span class="comment">// So it could be that we&#x27;re allocating one pointer and this was</span></span><br><span class="line">         <span class="comment">// just the smallest block available. Distinguish by checking dataSize.</span></span><br><span class="line">         <span class="comment">// (In general the number of instances of typ being allocated is</span></span><br><span class="line">         <span class="comment">// dataSize/typ.size.)</span></span><br><span class="line">         <span class="keyword">if</span> goarch.PtrSize == <span class="number">4</span> &amp;&amp; dataSize == goarch.PtrSize &#123;</span><br><span class="line">            <span class="comment">// 1 pointer object. On 32-bit machines clear the bit for the</span></span><br><span class="line">            <span class="comment">// unused second word.</span></span><br><span class="line">            *h.bitp &amp;^= (bitPointer | bitScan | (bitPointer|bitScan)&lt;&lt;heapBitsShift) &lt;&lt; h.shift</span><br><span class="line">            *h.bitp |= (bitPointer | bitScan) &lt;&lt; h.shift</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2-element array of pointer.</span></span><br><span class="line">            *h.bitp |= (bitPointer | bitScan | (bitPointer|bitScan)&lt;&lt;heapBitsShift) &lt;&lt; h.shift</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Otherwise typ.size must be 2*goarch.PtrSize,</span></span><br><span class="line">      <span class="comment">// and typ.kind&amp;kindGCProg == 0.</span></span><br><span class="line">      <span class="keyword">if</span> doubleCheck &#123;</span><br><span class="line">         <span class="keyword">if</span> typ.size != <span class="number">2</span>*goarch.PtrSize || typ.kind&amp;kindGCProg != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: heapBitsSetType size=&quot;</span>, size, <span class="string">&quot; but typ.size=&quot;</span>, typ.size, <span class="string">&quot; gcprog=&quot;</span>, typ.kind&amp;kindGCProg != <span class="number">0</span>, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;heapBitsSetType&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      b := <span class="type">uint32</span>(*ptrmask)</span><br><span class="line">      hb := b &amp; <span class="number">3</span></span><br><span class="line">      hb |= bitScanAll &amp; ((bitScan &lt;&lt; (typ.ptrdata / goarch.PtrSize)) - <span class="number">1</span>)</span><br><span class="line">      <span class="comment">// Clear the bits for this object so we can set the</span></span><br><span class="line">      <span class="comment">// appropriate ones.</span></span><br><span class="line">      *h.bitp &amp;^= (bitPointer | bitScan | ((bitPointer | bitScan) &lt;&lt; heapBitsShift)) &lt;&lt; h.shift</span><br><span class="line">      *h.bitp |= <span class="type">uint8</span>(hb &lt;&lt; h.shift)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> size == <span class="number">3</span>*goarch.PtrSize &#123;</span><br><span class="line">      b := <span class="type">uint8</span>(*ptrmask)</span><br><span class="line">      <span class="keyword">if</span> doubleCheck &#123;</span><br><span class="line">         <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: invalid type &quot;</span>, typ.<span class="type">string</span>())</span><br><span class="line">            throw(<span class="string">&quot;heapBitsSetType: called with non-pointer type&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> goarch.PtrSize != <span class="number">8</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;heapBitsSetType: unexpected 3 pointer wide size class on 32 bit&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> typ.kind&amp;kindGCProg != <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;heapBitsSetType: unexpected GC prog for 3 pointer wide size class&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> typ.size == <span class="number">2</span>*goarch.PtrSize &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: heapBitsSetType size=&quot;</span>, size, <span class="string">&quot; but typ.size=&quot;</span>, typ.size, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;heapBitsSetType: inconsistent object sizes&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> typ.size == goarch.PtrSize &#123;</span><br><span class="line">         <span class="comment">// The type contains a pointer otherwise heapBitsSetType wouldn&#x27;t have been called.</span></span><br><span class="line">         <span class="comment">// Since the type is only 1 pointer wide and contains a pointer, its gcdata must be exactly 1.</span></span><br><span class="line">         <span class="keyword">if</span> doubleCheck &amp;&amp; *typ.gcdata != <span class="number">1</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: heapBitsSetType size=&quot;</span>, size, <span class="string">&quot; typ.size=&quot;</span>, typ.size, <span class="string">&quot;but *typ.gcdata&quot;</span>, *typ.gcdata, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;heapBitsSetType: unexpected gcdata for 1 pointer wide type size in 3 pointer wide size class&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 3 element array of pointers. Unrolling ptrmask 3 times into p yields 00000111.</span></span><br><span class="line">         b = <span class="number">7</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      hb := b &amp; <span class="number">7</span></span><br><span class="line">      <span class="comment">// Set bitScan bits for all pointers.</span></span><br><span class="line">      hb |= hb &lt;&lt; wordsPerBitmapByte</span><br><span class="line">      <span class="comment">// First bitScan bit is always set since the type contains pointers.</span></span><br><span class="line">      hb |= bitScan</span><br><span class="line">      <span class="comment">// Second bitScan bit needs to also be set if the third bitScan bit is set.</span></span><br><span class="line">      hb |= hb &amp; (bitScan &lt;&lt; (<span class="number">2</span> * heapBitsShift)) &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// For h.shift &gt; 1 heap bits cross a byte boundary and need to be written part</span></span><br><span class="line">      <span class="comment">// to h.bitp and part to the next h.bitp.</span></span><br><span class="line">      <span class="keyword">switch</span> h.shift &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">         *h.bitp &amp;^= mask3 &lt;&lt; <span class="number">0</span></span><br><span class="line">         *h.bitp |= hb &lt;&lt; <span class="number">0</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">         *h.bitp &amp;^= mask3 &lt;&lt; <span class="number">1</span></span><br><span class="line">         *h.bitp |= hb &lt;&lt; <span class="number">1</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">         *h.bitp &amp;^= mask2 &lt;&lt; <span class="number">2</span></span><br><span class="line">         *h.bitp |= (hb &amp; mask2) &lt;&lt; <span class="number">2</span></span><br><span class="line">         <span class="comment">// Two words written to the first byte.</span></span><br><span class="line">         <span class="comment">// Advance two words to get to the next byte.</span></span><br><span class="line">         h = h.next().next()</span><br><span class="line">         *h.bitp &amp;^= mask1</span><br><span class="line">         *h.bitp |= (hb &gt;&gt; <span class="number">2</span>) &amp; mask1</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">         *h.bitp &amp;^= mask1 &lt;&lt; <span class="number">3</span></span><br><span class="line">         *h.bitp |= (hb &amp; mask1) &lt;&lt; <span class="number">3</span></span><br><span class="line">         <span class="comment">// One word written to the first byte.</span></span><br><span class="line">         <span class="comment">// Advance one word to get to the next byte.</span></span><br><span class="line">         h = h.next()</span><br><span class="line">         *h.bitp &amp;^= mask2</span><br><span class="line">         *h.bitp |= (hb &gt;&gt; <span class="number">1</span>) &amp; mask2</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Copy from 1-bit ptrmask into 2-bit bitmap.</span></span><br><span class="line">   <span class="comment">// The basic approach is to use a single uintptr as a bit buffer,</span></span><br><span class="line">   <span class="comment">// alternating between reloading the buffer and writing bitmap bytes.</span></span><br><span class="line">   <span class="comment">// In general, one load can supply two bitmap byte writes.</span></span><br><span class="line">   <span class="comment">// This is a lot of lines of code, but it compiles into relatively few</span></span><br><span class="line">   <span class="comment">// machine instructions.</span></span><br><span class="line"></span><br><span class="line">   outOfPlace := <span class="literal">false</span></span><br><span class="line">   <span class="keyword">if</span> arenaIndex(x+size<span class="number">-1</span>) != arenaIdx(h.arena) || (doubleCheck &amp;&amp; fastrandn(<span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// This object spans heap arenas, so the bitmap may be</span></span><br><span class="line">      <span class="comment">// discontiguous. Unroll it into the object instead</span></span><br><span class="line">      <span class="comment">// and then copy it out.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// In doubleCheck mode, we randomly do this anyway to</span></span><br><span class="line">      <span class="comment">// stress test the bitmap copying path.</span></span><br><span class="line">      outOfPlace = <span class="literal">true</span></span><br><span class="line">      h.bitp = (*<span class="type">uint8</span>)(unsafe.Pointer(x))</span><br><span class="line">      h.last = <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> (</span><br><span class="line">      <span class="comment">// Ptrmask input.</span></span><br><span class="line">      p     *<span class="type">byte</span>   <span class="comment">// last ptrmask byte read</span></span><br><span class="line">      b     <span class="type">uintptr</span> <span class="comment">// ptrmask bits already loaded</span></span><br><span class="line">      nb    <span class="type">uintptr</span> <span class="comment">// number of bits in b at next read</span></span><br><span class="line">      endp  *<span class="type">byte</span>   <span class="comment">// final ptrmask byte to read (then repeat)</span></span><br><span class="line">      endnb <span class="type">uintptr</span> <span class="comment">// number of valid bits in *endp</span></span><br><span class="line">      pbits <span class="type">uintptr</span> <span class="comment">// alternate source of bits</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Heap bitmap output.</span></span><br><span class="line">      w     <span class="type">uintptr</span> <span class="comment">// words processed</span></span><br><span class="line">      nw    <span class="type">uintptr</span> <span class="comment">// number of words to process</span></span><br><span class="line">      hbitp *<span class="type">byte</span>   <span class="comment">// next heap bitmap byte to write</span></span><br><span class="line">      hb    <span class="type">uintptr</span> <span class="comment">// bits being prepared for *hbitp</span></span><br><span class="line">   )</span><br><span class="line"></span><br><span class="line">   hbitp = h.bitp</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Handle GC program. Delayed until this part of the code</span></span><br><span class="line">   <span class="comment">// so that we can use the same double-checking mechanism</span></span><br><span class="line">   <span class="comment">// as the 1-bit case. Nothing above could have encountered</span></span><br><span class="line">   <span class="comment">// GC programs: the cases were all too small.</span></span><br><span class="line">   <span class="keyword">if</span> typ.kind&amp;kindGCProg != <span class="number">0</span> &#123;</span><br><span class="line">      heapBitsSetTypeGCProg(h, typ.ptrdata, typ.size, dataSize, size, addb(typ.gcdata, <span class="number">4</span>))</span><br><span class="line">      <span class="keyword">if</span> doubleCheck &#123;</span><br><span class="line">         <span class="comment">// Double-check the heap bits written by GC program</span></span><br><span class="line">         <span class="comment">// by running the GC program to create a 1-bit pointer mask</span></span><br><span class="line">         <span class="comment">// and then jumping to the double-check code below.</span></span><br><span class="line">         <span class="comment">// This doesn&#x27;t catch bugs shared between the 1-bit and 4-bit</span></span><br><span class="line">         <span class="comment">// GC program execution, but it does catch mistakes specific</span></span><br><span class="line">         <span class="comment">// to just one of those and bugs in heapBitsSetTypeGCProg&#x27;s</span></span><br><span class="line">         <span class="comment">// implementation of arrays.</span></span><br><span class="line">         lock(&amp;debugPtrmask.lock)</span><br><span class="line">         <span class="keyword">if</span> debugPtrmask.data == <span class="literal">nil</span> &#123;</span><br><span class="line">            debugPtrmask.data = (*<span class="type">byte</span>)(persistentalloc(<span class="number">1</span>&lt;&lt;<span class="number">20</span>, <span class="number">1</span>, &amp;memstats.other_sys))</span><br><span class="line">         &#125;</span><br><span class="line">         ptrmask = debugPtrmask.data</span><br><span class="line">         runGCProg(addb(typ.gcdata, <span class="number">4</span>), <span class="literal">nil</span>, ptrmask, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">goto</span> Phase4</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Note about sizes:</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// typ.size is the number of words in the object,</span></span><br><span class="line">   <span class="comment">// and typ.ptrdata is the number of words in the prefix</span></span><br><span class="line">   <span class="comment">// of the object that contains pointers. That is, the final</span></span><br><span class="line">   <span class="comment">// typ.size - typ.ptrdata words contain no pointers.</span></span><br><span class="line">   <span class="comment">// This allows optimization of a common pattern where</span></span><br><span class="line">   <span class="comment">// an object has a small header followed by a large scalar</span></span><br><span class="line">   <span class="comment">// buffer. If we know the pointers are over, we don&#x27;t have</span></span><br><span class="line">   <span class="comment">// to scan the buffer&#x27;s heap bitmap at all.</span></span><br><span class="line">   <span class="comment">// The 1-bit ptrmasks are sized to contain only bits for</span></span><br><span class="line">   <span class="comment">// the typ.ptrdata prefix, zero padded out to a full byte</span></span><br><span class="line">   <span class="comment">// of bitmap. This code sets nw (below) so that heap bitmap</span></span><br><span class="line">   <span class="comment">// bits are only written for the typ.ptrdata prefix; if there is</span></span><br><span class="line">   <span class="comment">// more room in the allocated object, the next heap bitmap</span></span><br><span class="line">   <span class="comment">// entry is a 00, indicating that there are no more pointers</span></span><br><span class="line">   <span class="comment">// to scan. So only the ptrmask for the ptrdata bytes is needed.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// Replicated copies are not as nice: if there is an array of</span></span><br><span class="line">   <span class="comment">// objects with scalar tails, all but the last tail does have to</span></span><br><span class="line">   <span class="comment">// be initialized, because there is no way to say &quot;skip forward&quot;.</span></span><br><span class="line">   <span class="comment">// However, because of the possibility of a repeated type with</span></span><br><span class="line">   <span class="comment">// size not a multiple of 4 pointers (one heap bitmap byte),</span></span><br><span class="line">   <span class="comment">// the code already must handle the last ptrmask byte specially</span></span><br><span class="line">   <span class="comment">// by treating it as containing only the bits for endnb pointers,</span></span><br><span class="line">   <span class="comment">// where endnb &lt;= 4. We represent large scalar tails that must</span></span><br><span class="line">   <span class="comment">// be expanded in the replication by setting endnb larger than 4.</span></span><br><span class="line">   <span class="comment">// This will have the effect of reading many bits out of b,</span></span><br><span class="line">   <span class="comment">// but once the real bits are shifted out, b will supply as many</span></span><br><span class="line">   <span class="comment">// zero bits as we try to read, which is exactly what we need.</span></span><br><span class="line"></span><br><span class="line">   p = ptrmask</span><br><span class="line">   <span class="keyword">if</span> typ.size &lt; dataSize &#123;</span><br><span class="line">      <span class="comment">// Filling in bits for an array of typ.</span></span><br><span class="line">      <span class="comment">// Set up for repetition of ptrmask during main loop.</span></span><br><span class="line">      <span class="comment">// Note that ptrmask describes only a prefix of</span></span><br><span class="line">      <span class="keyword">const</span> maxBits = goarch.PtrSize*<span class="number">8</span> - <span class="number">7</span></span><br><span class="line">      <span class="keyword">if</span> typ.ptrdata/goarch.PtrSize &lt;= maxBits &#123;</span><br><span class="line">         <span class="comment">// Entire ptrmask fits in uintptr with room for a byte fragment.</span></span><br><span class="line">         <span class="comment">// Load into pbits and never read from ptrmask again.</span></span><br><span class="line">         <span class="comment">// This is especially important when the ptrmask has</span></span><br><span class="line">         <span class="comment">// fewer than 8 bits in it; otherwise the reload in the middle</span></span><br><span class="line">         <span class="comment">// of the Phase 2 loop would itself need to loop to gather</span></span><br><span class="line">         <span class="comment">// at least 8 bits.</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// Accumulate ptrmask into b.</span></span><br><span class="line">         <span class="comment">// ptrmask is sized to describe only typ.ptrdata, but we record</span></span><br><span class="line">         <span class="comment">// it as describing typ.size bytes, since all the high bits are zero.</span></span><br><span class="line">         nb = typ.ptrdata / goarch.PtrSize</span><br><span class="line">         <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; nb; i += <span class="number">8</span> &#123;</span><br><span class="line">            b |= <span class="type">uintptr</span>(*p) &lt;&lt; i</span><br><span class="line">            p = add1(p)</span><br><span class="line">         &#125;</span><br><span class="line">         nb = typ.size / goarch.PtrSize</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Replicate ptrmask to fill entire pbits uintptr.</span></span><br><span class="line">         <span class="comment">// Doubling and truncating is fewer steps than</span></span><br><span class="line">         <span class="comment">// iterating by nb each time. (nb could be 1.)</span></span><br><span class="line">         <span class="comment">// Since we loaded typ.ptrdata/goarch.PtrSize bits</span></span><br><span class="line">         <span class="comment">// but are pretending to have typ.size/goarch.PtrSize,</span></span><br><span class="line">         <span class="comment">// there might be no replication necessary/possible.</span></span><br><span class="line">         pbits = b</span><br><span class="line">         endnb = nb</span><br><span class="line">         <span class="keyword">if</span> nb+nb &lt;= maxBits &#123;</span><br><span class="line">            <span class="keyword">for</span> endnb &lt;= goarch.PtrSize*<span class="number">8</span> &#123;</span><br><span class="line">               pbits |= pbits &lt;&lt; endnb</span><br><span class="line">               endnb += endnb</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Truncate to a multiple of original ptrmask.</span></span><br><span class="line">            <span class="comment">// Because nb+nb &lt;= maxBits, nb fits in a byte.</span></span><br><span class="line">            <span class="comment">// Byte division is cheaper than uintptr division.</span></span><br><span class="line">            endnb = <span class="type">uintptr</span>(maxBits/<span class="type">byte</span>(nb)) * nb</span><br><span class="line">            pbits &amp;= <span class="number">1</span>&lt;&lt;endnb - <span class="number">1</span></span><br><span class="line">            b = pbits</span><br><span class="line">            nb = endnb</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Clear p and endp as sentinel for using pbits.</span></span><br><span class="line">         <span class="comment">// Checked during Phase 2 loop.</span></span><br><span class="line">         p = <span class="literal">nil</span></span><br><span class="line">         endp = <span class="literal">nil</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Ptrmask is larger. Read it multiple times.</span></span><br><span class="line">         n := (typ.ptrdata/goarch.PtrSize+<span class="number">7</span>)/<span class="number">8</span> - <span class="number">1</span></span><br><span class="line">         endp = addb(ptrmask, n)</span><br><span class="line">         endnb = typ.size/goarch.PtrSize - n*<span class="number">8</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">      b = <span class="type">uintptr</span>(*p)</span><br><span class="line">      p = add1(p)</span><br><span class="line">      nb = <span class="number">8</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> typ.size == dataSize &#123;</span><br><span class="line">      <span class="comment">// Single entry: can stop once we reach the non-pointer data.</span></span><br><span class="line">      nw = typ.ptrdata / goarch.PtrSize</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Repeated instances of typ in an array.</span></span><br><span class="line">      <span class="comment">// Have to process first N-1 entries in full, but can stop</span></span><br><span class="line">      <span class="comment">// once we reach the non-pointer data in the final entry.</span></span><br><span class="line">      nw = ((dataSize/typ.size<span class="number">-1</span>)*typ.size + typ.ptrdata) / goarch.PtrSize</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> nw == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// No pointers! Caller was supposed to check.</span></span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;runtime: invalid type &quot;</span>, typ.<span class="type">string</span>())</span><br><span class="line">      throw(<span class="string">&quot;heapBitsSetType: called with non-pointer type&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Phase 1: Special case for leading byte (shift==0) or half-byte (shift==2).</span></span><br><span class="line">   <span class="comment">// The leading byte is special because it contains the bits for word 1,</span></span><br><span class="line">   <span class="comment">// which does not have the scan bit set.</span></span><br><span class="line">   <span class="comment">// The leading half-byte is special because it&#x27;s a half a byte,</span></span><br><span class="line">   <span class="comment">// so we have to be careful with the bits already there.</span></span><br><span class="line">   <span class="keyword">switch</span> &#123;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      throw(<span class="string">&quot;heapBitsSetType: unexpected shift&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">case</span> h.shift == <span class="number">0</span>:</span><br><span class="line">      <span class="comment">// Ptrmask and heap bitmap are aligned.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// This is a fast path for small objects.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// The first byte we write out covers the first four</span></span><br><span class="line">      <span class="comment">// words of the object. The scan/dead bit on the first</span></span><br><span class="line">      <span class="comment">// word must be set to scan since there are pointers</span></span><br><span class="line">      <span class="comment">// somewhere in the object.</span></span><br><span class="line">      <span class="comment">// In all following words, we set the scan/dead</span></span><br><span class="line">      <span class="comment">// appropriately to indicate that the object continues</span></span><br><span class="line">      <span class="comment">// to the next 2-bit entry in the bitmap.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// We set four bits at a time here, but if the object</span></span><br><span class="line">      <span class="comment">// is fewer than four words, phase 3 will clear</span></span><br><span class="line">      <span class="comment">// unnecessary bits.</span></span><br><span class="line">      hb = b &amp; bitPointerAll</span><br><span class="line">      hb |= bitScanAll</span><br><span class="line">      <span class="keyword">if</span> w += <span class="number">4</span>; w &gt;= nw &#123;</span><br><span class="line">         <span class="keyword">goto</span> Phase3</span><br><span class="line">      &#125;</span><br><span class="line">      *hbitp = <span class="type">uint8</span>(hb)</span><br><span class="line">      hbitp = add1(hbitp)</span><br><span class="line">      b &gt;&gt;= <span class="number">4</span></span><br><span class="line">      nb -= <span class="number">4</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">case</span> h.shift == <span class="number">2</span>:</span><br><span class="line">      <span class="comment">// Ptrmask and heap bitmap are misaligned.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// On 32 bit architectures only the 6-word object that corresponds</span></span><br><span class="line">      <span class="comment">// to a 24 bytes size class can start with h.shift of 2 here since</span></span><br><span class="line">      <span class="comment">// all other non 16 byte aligned size classes have been handled by</span></span><br><span class="line">      <span class="comment">// special code paths at the beginning of heapBitsSetType on 32 bit.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Many size classes are only 16 byte aligned. On 64 bit architectures</span></span><br><span class="line">      <span class="comment">// this results in a heap bitmap position starting with a h.shift of 2.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// The bits for the first two words are in a byte shared</span></span><br><span class="line">      <span class="comment">// with another object, so we must be careful with the bits</span></span><br><span class="line">      <span class="comment">// already there.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// We took care of 1-word, 2-word, and 3-word objects above,</span></span><br><span class="line">      <span class="comment">// so this is at least a 6-word object.</span></span><br><span class="line">      hb = (b &amp; (bitPointer | bitPointer&lt;&lt;heapBitsShift)) &lt;&lt; (<span class="number">2</span> * heapBitsShift)</span><br><span class="line">      hb |= bitScan &lt;&lt; (<span class="number">2</span> * heapBitsShift)</span><br><span class="line">      <span class="keyword">if</span> nw &gt; <span class="number">1</span> &#123;</span><br><span class="line">         hb |= bitScan &lt;&lt; (<span class="number">3</span> * heapBitsShift)</span><br><span class="line">      &#125;</span><br><span class="line">      b &gt;&gt;= <span class="number">2</span></span><br><span class="line">      nb -= <span class="number">2</span></span><br><span class="line">      *hbitp &amp;^= <span class="type">uint8</span>((bitPointer | bitScan | ((bitPointer | bitScan) &lt;&lt; heapBitsShift)) &lt;&lt; (<span class="number">2</span> * heapBitsShift))</span><br><span class="line">      *hbitp |= <span class="type">uint8</span>(hb)</span><br><span class="line">      hbitp = add1(hbitp)</span><br><span class="line">      <span class="keyword">if</span> w += <span class="number">2</span>; w &gt;= nw &#123;</span><br><span class="line">         <span class="comment">// We know that there is more data, because we handled 2-word and 3-word objects above.</span></span><br><span class="line">         <span class="comment">// This must be at least a 6-word object. If we&#x27;re out of pointer words,</span></span><br><span class="line">         <span class="comment">// mark no scan in next bitmap byte and finish.</span></span><br><span class="line">         hb = <span class="number">0</span></span><br><span class="line">         w += <span class="number">4</span></span><br><span class="line">         <span class="keyword">goto</span> Phase3</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Phase 2: Full bytes in bitmap, up to but not including write to last byte (full or partial) in bitmap.</span></span><br><span class="line">   <span class="comment">// The loop computes the bits for that last write but does not execute the write;</span></span><br><span class="line">   <span class="comment">// it leaves the bits in hb for processing by phase 3.</span></span><br><span class="line">   <span class="comment">// To avoid repeated adjustment of nb, we subtract out the 4 bits we&#x27;re going to</span></span><br><span class="line">   <span class="comment">// use in the first half of the loop right now, and then we only adjust nb explicitly</span></span><br><span class="line">   <span class="comment">// if the 8 bits used by each iteration isn&#x27;t balanced by 8 bits loaded mid-loop.</span></span><br><span class="line">   nb -= <span class="number">4</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">// Emit bitmap byte.</span></span><br><span class="line">      <span class="comment">// b has at least nb+4 bits, with one exception:</span></span><br><span class="line">      <span class="comment">// if w+4 &gt;= nw, then b has only nw-w bits,</span></span><br><span class="line">      <span class="comment">// but we&#x27;ll stop at the break and then truncate</span></span><br><span class="line">      <span class="comment">// appropriately in Phase 3.</span></span><br><span class="line">      hb = b &amp; bitPointerAll</span><br><span class="line">      hb |= bitScanAll</span><br><span class="line">      <span class="keyword">if</span> w += <span class="number">4</span>; w &gt;= nw &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      *hbitp = <span class="type">uint8</span>(hb)</span><br><span class="line">      hbitp = add1(hbitp)</span><br><span class="line">      b &gt;&gt;= <span class="number">4</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Load more bits. b has nb right now.</span></span><br><span class="line">      <span class="keyword">if</span> p != endp &#123;</span><br><span class="line">         <span class="comment">// Fast path: keep reading from ptrmask.</span></span><br><span class="line">         <span class="comment">// nb unmodified: we just loaded 8 bits,</span></span><br><span class="line">         <span class="comment">// and the next iteration will consume 8 bits,</span></span><br><span class="line">         <span class="comment">// leaving us with the same nb the next time we&#x27;re here.</span></span><br><span class="line">         <span class="keyword">if</span> nb &lt; <span class="number">8</span> &#123;</span><br><span class="line">            b |= <span class="type">uintptr</span>(*p) &lt;&lt; nb</span><br><span class="line">            p = add1(p)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Reduce the number of bits in b.</span></span><br><span class="line">            <span class="comment">// This is important if we skipped</span></span><br><span class="line">            <span class="comment">// over a scalar tail, since nb could</span></span><br><span class="line">            <span class="comment">// be larger than the bit width of b.</span></span><br><span class="line">            nb -= <span class="number">8</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="comment">// Almost as fast path: track bit count and refill from pbits.</span></span><br><span class="line">         <span class="comment">// For short repetitions.</span></span><br><span class="line">         <span class="keyword">if</span> nb &lt; <span class="number">8</span> &#123;</span><br><span class="line">            b |= pbits &lt;&lt; nb</span><br><span class="line">            nb += endnb</span><br><span class="line">         &#125;</span><br><span class="line">         nb -= <span class="number">8</span> <span class="comment">// for next iteration</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Slow path: reached end of ptrmask.</span></span><br><span class="line">         <span class="comment">// Process final partial byte and rewind to start.</span></span><br><span class="line">         b |= <span class="type">uintptr</span>(*p) &lt;&lt; nb</span><br><span class="line">         nb += endnb</span><br><span class="line">         <span class="keyword">if</span> nb &lt; <span class="number">8</span> &#123;</span><br><span class="line">            b |= <span class="type">uintptr</span>(*ptrmask) &lt;&lt; nb</span><br><span class="line">            p = add1(ptrmask)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nb -= <span class="number">8</span></span><br><span class="line">            p = ptrmask</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Emit bitmap byte.</span></span><br><span class="line">      hb = b &amp; bitPointerAll</span><br><span class="line">      hb |= bitScanAll</span><br><span class="line">      <span class="keyword">if</span> w += <span class="number">4</span>; w &gt;= nw &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      *hbitp = <span class="type">uint8</span>(hb)</span><br><span class="line">      hbitp = add1(hbitp)</span><br><span class="line">      b &gt;&gt;= <span class="number">4</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">Phase3:</span><br><span class="line">   <span class="comment">// Phase 3: Write last byte or partial byte and zero the rest of the bitmap entries.</span></span><br><span class="line">   <span class="keyword">if</span> w &gt; nw &#123;</span><br><span class="line">      <span class="comment">// Counting the 4 entries in hb not yet written to memory,</span></span><br><span class="line">      <span class="comment">// there are more entries than possible pointer slots.</span></span><br><span class="line">      <span class="comment">// Discard the excess entries (can&#x27;t be more than 3).</span></span><br><span class="line">      mask := <span class="type">uintptr</span>(<span class="number">1</span>)&lt;&lt;(<span class="number">4</span>-(w-nw)) - <span class="number">1</span></span><br><span class="line">      hb &amp;= mask | mask&lt;&lt;<span class="number">4</span> <span class="comment">// apply mask to both pointer bits and scan bits</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Change nw from counting possibly-pointer words to total words in allocation.</span></span><br><span class="line">   nw = size / goarch.PtrSize</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Write whole bitmap bytes.</span></span><br><span class="line">   <span class="comment">// The first is hb, the rest are zero.</span></span><br><span class="line">   <span class="keyword">if</span> w &lt;= nw &#123;</span><br><span class="line">      *hbitp = <span class="type">uint8</span>(hb)</span><br><span class="line">      hbitp = add1(hbitp)</span><br><span class="line">      hb = <span class="number">0</span> <span class="comment">// for possible final half-byte below</span></span><br><span class="line">      <span class="keyword">for</span> w += <span class="number">4</span>; w &lt;= nw; w += <span class="number">4</span> &#123;</span><br><span class="line">         *hbitp = <span class="number">0</span></span><br><span class="line">         hbitp = add1(hbitp)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Write final partial bitmap byte if any.</span></span><br><span class="line">   <span class="comment">// We know w &gt; nw, or else we&#x27;d still be in the loop above.</span></span><br><span class="line">   <span class="comment">// It can be bigger only due to the 4 entries in hb that it counts.</span></span><br><span class="line">   <span class="comment">// If w == nw+4 then there&#x27;s nothing left to do: we wrote all nw entries</span></span><br><span class="line">   <span class="comment">// and can discard the 4 sitting in hb.</span></span><br><span class="line">   <span class="comment">// But if w == nw+2, we need to write first two in hb.</span></span><br><span class="line">   <span class="comment">// The byte is shared with the next object, so be careful with</span></span><br><span class="line">   <span class="comment">// existing bits.</span></span><br><span class="line">   <span class="keyword">if</span> w == nw+<span class="number">2</span> &#123;</span><br><span class="line">      *hbitp = *hbitp&amp;^(bitPointer|bitScan|(bitPointer|bitScan)&lt;&lt;heapBitsShift) | <span class="type">uint8</span>(hb)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">Phase4:</span><br><span class="line">   <span class="comment">// Phase 4: Copy unrolled bitmap to per-arena bitmaps, if necessary.</span></span><br><span class="line">   <span class="keyword">if</span> outOfPlace &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> We could probably make this faster by</span></span><br><span class="line">      <span class="comment">// handling [x+dataSize, x+size) specially.</span></span><br><span class="line">      h := heapBitsForAddr(x)</span><br><span class="line">      <span class="comment">// cnw is the number of heap words, or bit pairs</span></span><br><span class="line">      <span class="comment">// remaining (like nw above).</span></span><br><span class="line">      cnw := size / goarch.PtrSize</span><br><span class="line">      src := (*<span class="type">uint8</span>)(unsafe.Pointer(x))</span><br><span class="line">      <span class="comment">// We know the first and last byte of the bitmap are</span></span><br><span class="line">      <span class="comment">// not the same, but it&#x27;s still possible for small</span></span><br><span class="line">      <span class="comment">// objects span arenas, so it may share bitmap bytes</span></span><br><span class="line">      <span class="comment">// with neighboring objects.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Handle the first byte specially if it&#x27;s shared. See</span></span><br><span class="line">      <span class="comment">// Phase 1 for why this is the only special case we need.</span></span><br><span class="line">      <span class="keyword">if</span> doubleCheck &#123;</span><br><span class="line">         <span class="keyword">if</span> !(h.shift == <span class="number">0</span> || h.shift == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;x=&quot;</span>, x, <span class="string">&quot; size=&quot;</span>, size, <span class="string">&quot; cnw=&quot;</span>, h.shift, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;bad start shift&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> h.shift == <span class="number">2</span> &#123;</span><br><span class="line">         *h.bitp = *h.bitp&amp;^((bitPointer|bitScan|(bitPointer|bitScan)&lt;&lt;heapBitsShift)&lt;&lt;(<span class="number">2</span>*heapBitsShift)) | *src</span><br><span class="line">         h = h.next().next()</span><br><span class="line">         cnw -= <span class="number">2</span></span><br><span class="line">         src = addb(src, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// We&#x27;re now byte aligned. Copy out to per-arena</span></span><br><span class="line">      <span class="comment">// bitmaps until the last byte (which may again be</span></span><br><span class="line">      <span class="comment">// partial).</span></span><br><span class="line">      <span class="keyword">for</span> cnw &gt;= <span class="number">4</span> &#123;</span><br><span class="line">         <span class="comment">// This loop processes four words at a time,</span></span><br><span class="line">         <span class="comment">// so round cnw down accordingly.</span></span><br><span class="line">         hNext, words := h.forwardOrBoundary(cnw / <span class="number">4</span> * <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">         <span class="comment">// n is the number of bitmap bytes to copy.</span></span><br><span class="line">         n := words / <span class="number">4</span></span><br><span class="line">         memmove(unsafe.Pointer(h.bitp), unsafe.Pointer(src), n)</span><br><span class="line">         cnw -= words</span><br><span class="line">         h = hNext</span><br><span class="line">         src = addb(src, n)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> doubleCheck &amp;&amp; h.shift != <span class="number">0</span> &#123;</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;cnw=&quot;</span>, cnw, <span class="string">&quot; h.shift=&quot;</span>, h.shift, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">         throw(<span class="string">&quot;bad shift after block copy&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Handle the last byte if it&#x27;s shared.</span></span><br><span class="line">      <span class="keyword">if</span> cnw == <span class="number">2</span> &#123;</span><br><span class="line">         *h.bitp = *h.bitp&amp;^(bitPointer|bitScan|(bitPointer|bitScan)&lt;&lt;heapBitsShift) | *src</span><br><span class="line">         src = addb(src, <span class="number">1</span>)</span><br><span class="line">         h = h.next().next()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> doubleCheck &#123;</span><br><span class="line">         <span class="keyword">if</span> <span class="type">uintptr</span>(unsafe.Pointer(src)) &gt; x+size &#123;</span><br><span class="line">            throw(<span class="string">&quot;copy exceeded object size&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> !(cnw == <span class="number">0</span> || cnw == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;x=&quot;</span>, x, <span class="string">&quot; size=&quot;</span>, size, <span class="string">&quot; cnw=&quot;</span>, cnw, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;bad number of remaining words&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// Set up hbitp so doubleCheck code below can check it.</span></span><br><span class="line">         hbitp = h.bitp</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Zero the object where we wrote the bitmap.</span></span><br><span class="line">      memclrNoHeapPointers(unsafe.Pointer(x), <span class="type">uintptr</span>(unsafe.Pointer(src))-x)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Double check the whole bitmap.</span></span><br><span class="line">   <span class="keyword">if</span> doubleCheck &#123;</span><br><span class="line">      <span class="comment">// x+size may not point to the heap, so back up one</span></span><br><span class="line">      <span class="comment">// word and then advance it the way we do above.</span></span><br><span class="line">      end := heapBitsForAddr(x + size - goarch.PtrSize)</span><br><span class="line">      <span class="keyword">if</span> outOfPlace &#123;</span><br><span class="line">         <span class="comment">// In out-of-place copying, we just advance</span></span><br><span class="line">         <span class="comment">// using next.</span></span><br><span class="line">         end = end.next()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Don&#x27;t use next because that may advance to</span></span><br><span class="line">         <span class="comment">// the next arena and the in-place logic</span></span><br><span class="line">         <span class="comment">// doesn&#x27;t do that.</span></span><br><span class="line">         end.shift += heapBitsShift</span><br><span class="line">         <span class="keyword">if</span> end.shift == <span class="number">4</span>*heapBitsShift &#123;</span><br><span class="line">            end.bitp, end.shift = add1(end.bitp), <span class="number">0</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> typ.kind&amp;kindGCProg == <span class="number">0</span> &amp;&amp; (hbitp != end.bitp || (w == nw+<span class="number">2</span>) != (end.shift == <span class="number">2</span>)) &#123;</span><br><span class="line">         <span class="built_in">println</span>(<span class="string">&quot;ended at wrong bitmap byte for&quot;</span>, typ.<span class="type">string</span>(), <span class="string">&quot;x&quot;</span>, dataSize/typ.size)</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;typ.size=&quot;</span>, typ.size, <span class="string">&quot; typ.ptrdata=&quot;</span>, typ.ptrdata, <span class="string">&quot; dataSize=&quot;</span>, dataSize, <span class="string">&quot; size=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;w=&quot;</span>, w, <span class="string">&quot; nw=&quot;</span>, nw, <span class="string">&quot; b=&quot;</span>, hex(b), <span class="string">&quot; nb=&quot;</span>, nb, <span class="string">&quot; hb=&quot;</span>, hex(hb), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">         h0 := heapBitsForAddr(x)</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;initial bits h0.bitp=&quot;</span>, h0.bitp, <span class="string">&quot; h0.shift=&quot;</span>, h0.shift, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;ended at hbitp=&quot;</span>, hbitp, <span class="string">&quot; but next starts at bitp=&quot;</span>, end.bitp, <span class="string">&quot; shift=&quot;</span>, end.shift, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">         throw(<span class="string">&quot;bad heapBitsSetType&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Double-check that bits to be written were written correctly.</span></span><br><span class="line">      <span class="comment">// Does not check that other bits were not written, unfortunately.</span></span><br><span class="line">      h := heapBitsForAddr(x)</span><br><span class="line">      nptr := typ.ptrdata / goarch.PtrSize</span><br><span class="line">      ndata := typ.size / goarch.PtrSize</span><br><span class="line">      count := dataSize / typ.size</span><br><span class="line">      totalptr := ((count<span class="number">-1</span>)*typ.size + typ.ptrdata) / goarch.PtrSize</span><br><span class="line">      <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; size/goarch.PtrSize; i++ &#123;</span><br><span class="line">         j := i % ndata</span><br><span class="line">         <span class="keyword">var</span> have, want <span class="type">uint8</span></span><br><span class="line">         have = (*h.bitp &gt;&gt; h.shift) &amp; (bitPointer | bitScan)</span><br><span class="line">         <span class="keyword">if</span> i &gt;= totalptr &#123;</span><br><span class="line">            <span class="keyword">if</span> typ.kind&amp;kindGCProg != <span class="number">0</span> &amp;&amp; i &lt; (totalptr+<span class="number">3</span>)/<span class="number">4</span>*<span class="number">4</span> &#123;</span><br><span class="line">               <span class="comment">// heapBitsSetTypeGCProg always fills</span></span><br><span class="line">               <span class="comment">// in full nibbles of bitScan.</span></span><br><span class="line">               want = bitScan</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> j &lt; nptr &amp;&amp; (*addb(ptrmask, j/<span class="number">8</span>)&gt;&gt;(j%<span class="number">8</span>))&amp;<span class="number">1</span> != <span class="number">0</span> &#123;</span><br><span class="line">               want |= bitPointer</span><br><span class="line">            &#125;</span><br><span class="line">            want |= bitScan</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> have != want &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;mismatch writing bits for&quot;</span>, typ.<span class="type">string</span>(), <span class="string">&quot;x&quot;</span>, dataSize/typ.size)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;typ.size=&quot;</span>, typ.size, <span class="string">&quot; typ.ptrdata=&quot;</span>, typ.ptrdata, <span class="string">&quot; dataSize=&quot;</span>, dataSize, <span class="string">&quot; size=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;kindGCProg=&quot;</span>, typ.kind&amp;kindGCProg != <span class="number">0</span>, <span class="string">&quot; outOfPlace=&quot;</span>, outOfPlace, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;w=&quot;</span>, w, <span class="string">&quot; nw=&quot;</span>, nw, <span class="string">&quot; b=&quot;</span>, hex(b), <span class="string">&quot; nb=&quot;</span>, nb, <span class="string">&quot; hb=&quot;</span>, hex(hb), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            h0 := heapBitsForAddr(x)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;initial bits h0.bitp=&quot;</span>, h0.bitp, <span class="string">&quot; h0.shift=&quot;</span>, h0.shift, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;current bits h.bitp=&quot;</span>, h.bitp, <span class="string">&quot; h.shift=&quot;</span>, h.shift, <span class="string">&quot; *h.bitp=&quot;</span>, hex(*h.bitp), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;ptrmask=&quot;</span>, ptrmask, <span class="string">&quot; p=&quot;</span>, p, <span class="string">&quot; endp=&quot;</span>, endp, <span class="string">&quot; endnb=&quot;</span>, endnb, <span class="string">&quot; pbits=&quot;</span>, hex(pbits), <span class="string">&quot; b=&quot;</span>, hex(b), <span class="string">&quot; nb=&quot;</span>, nb, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;at word&quot;</span>, i, <span class="string">&quot;offset&quot;</span>, i*goarch.PtrSize, <span class="string">&quot;have&quot;</span>, hex(have), <span class="string">&quot;want&quot;</span>, hex(want))</span><br><span class="line">            <span class="keyword">if</span> typ.kind&amp;kindGCProg != <span class="number">0</span> &#123;</span><br><span class="line">               <span class="built_in">println</span>(<span class="string">&quot;GC program:&quot;</span>)</span><br><span class="line">               dumpGCProg(addb(typ.gcdata, <span class="number">4</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            throw(<span class="string">&quot;bad heapBitsSetType&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">         h = h.next()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ptrmask == debugPtrmask.data &#123;</span><br><span class="line">         unlock(&amp;debugPtrmask.lock)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="递进式内存申请">递进式内存申请</h5>
<p>在为对象申请内存时，采用递进式内存申请如下图所示，当某一级对象不够用，则向后一级申请。</p>
<p><img src="/assets/images/golearing/image-20220612210436224.png" alt="image-20220612210436224"></p>

</div>


  <div class="book-comments">
    




  </div>



<script src="/js/book-post.js"></script>

        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="F"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>Fred</div>
      <div>2022-06-12</div>
    </div>
  </div>
  
  

  <div class="divider"></div>
</div>
  
  <div class="busuanzi-count">
  <div>
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css">
    <span>
      <span>
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span>
      <span>
        <i class="fa fa-eye"></i>
      </span>
      <span class="page-pv" title="Viewers">
        <span id="busuanzi_value_page_pv"></span>
      </span>
    </span>
  <div>
  <div class="divider"></div>
</div>

  <div class="book-tocbot">
</div>
<!-- <div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div> -->


<script src="/js/book-toc.js"></script>

</div>
      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>


<script src="/js/book.js"></script>
